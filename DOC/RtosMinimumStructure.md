# 一个最小RTOS需要哪些东西
<!-- TOC -->

- [一个最小RTOS需要哪些东西](#一个最小rtos需要哪些东西)
    - [系统要求](#系统要求)
        - [调度方式为抢占式调度](#调度方式为抢占式调度)
        - [栈生长方向](#栈生长方向)
    - [1、需要一个能运行的裸机程序](#1需要一个能运行的裸机程序)
    - [2、首先实现最基本任务切换功能](#2首先实现最基本任务切换功能)
        - [任务控制块TCB](#任务控制块tcb)
        - [全局变量和数据结构](#全局变量和数据结构)
        - [任务初始化](#任务初始化)
        - [系统心跳（时钟节拍）](#系统心跳时钟节拍)
        - [任务栈结构](#任务栈结构)
- [遇到的困难](#遇到的困难)

<!-- /TOC -->

## 系统要求  
### 调度方式为抢占式调度  
调度的概念，通俗的说就是系统在多个任务中选择合适的任务执行。系统如何知道何时该执行哪个任务？可以为每个任务安排一唯一的优先级别，当同时有 多个任务就绪时，优先运行优先级较高的任务。  
  
所谓“抢占式调度 ”是指一旦就绪状态中出现优先权更高的任务，便立即剥夺当前任务的运行权，把把CPU分配给更高优先级的任务。样这样CPU总是执行处于就绪条件下优先级最高的任务。  

### 栈生长方向  
本项目采用的芯片是STM32F103ZET,栈生长方向向下。  

## 1、需要一个能运行的裸机程序  
一个能点亮LED的程序

## 2、首先实现最基本任务切换功能  
### 任务控制块TCB  
- 当前任务的状态（就绪，执行，阻塞）  
- 任务的优先级  
- 阻塞节拍数  
- 任务保存的栈顶指针指向任务栈。
（每个任务又要有一个自己的任务栈）  
- 双链表指针  

### 全局变量和数据结构
- 任务就绪表  
- 任务优先级表  
- 任务控制块链表  
- 当前任务TCB指针  
- 当前任务优先级  
- 当前最高优先级的就绪任务TCB指针  
- 当前最高优先级的就绪任务


### 任务初始化  
- 将所有全局变量和数据结构初始化
- 创建IDLE，并赋予最低优先级和永远就绪状态


### 系统心跳（时钟节拍） 
采用一个定时器产生时钟节拍  
中断处理  
遍历每一个任务  
查看当前系统的每个不为STOP的任务的delay时间。
把每个不为0的delay减一。  
当有delay减到0时，把该任务置位就绪


### 任务栈结构  


# 遇到的困难 
本想全部采用MSP
开一个系统栈 
基于中断的任务切换时，发现平台没有提供总的中断入口，而是有硬件直接跳转到ISR。 
任务切换不能在中断还未完全退出时进行   
无法统计中断嵌套层数，就不知道什么时候切换任务。  

解决办法，任务切换方式改为cm3内核提供的PendSV异常，把PendSV异常的优先级设置为最低。这样就会在最后一个中断ISR完成后进入PenSV的Handler函数。




